#!/usr/bin/env python3
"""
Apply all fixes to swarm_mas_unified.py and autonomous_fixed.py
This script patches the files to fix all known issues
"""

import os
import sys
import re
from datetime import datetime

def fix_visibility_level_comparison():
    """Fix the VisibilityLevel comparison error in swarm_mas_unified.py"""
    print("üîß Fixing VisibilityLevel comparison error...")
    
    file_path = '/app/src/swarm_mas_unified.py'
    
    try:
        with open(file_path, 'r') as f:
            content = f.read()
        
        # Find and fix the _get_visible_resources method
        pattern = r'(def _get_visible_resources\(self, visibility: VisibilityLevel\)[^:]*:\s*"""[^"]*"""\s*)'
        
        # Find the method
        match = re.search(pattern + r'(.*?)(?=\n    def|\nclass|\Z)', content, re.DOTALL)
        
        if match:
            method_start = match.group(1)
            old_body = match.group(2)
            
            # Create the fixed method body
            new_body = '''if not isinstance(visibility, VisibilityLevel):
            visibility = VisibilityLevel.NONE
            
        if visibility == VisibilityLevel.FULL:
            return self.resources.copy()
        elif visibility.value >= VisibilityLevel.NAMESPACE.value:  # Use .value for comparison
            # Show utilization only
            return {
                res_type: {
                    'utilization': data['utilization']
                }
                for res_type, data in self.resources.items()
            }
        else:
            return {}'''
            
            # Replace the method body
            new_method = method_start + new_body
            content = content.replace(match.group(0), new_method + '\n')
            
            # Save the fixed file
            with open(file_path, 'w') as f:
                f.write(content)
            
            print("‚úÖ Fixed VisibilityLevel comparison")
            return True
        else:
            print("‚ö†Ô∏è Could not find _get_visible_resources method")
            return False
            
    except Exception as e:
        print(f"‚ùå Error fixing VisibilityLevel: {e}")
        return False

def ensure_task_execution():
    """Ensure tasks are actually executed in swarm_mas_unified.py"""
    print("\nüîß Ensuring task execution in swarm_mas_unified.py...")
    
    file_path = '/app/src/swarm_mas_unified.py'
    
    try:
        with open(file_path, 'r') as f:
            content = f.read()
        
        # Check if _execute_task_with_agent creates real files
        if "os.makedirs" not in content or "files_created" not in content:
            print("‚ö†Ô∏è _execute_task_with_agent doesn't create real files")
            
            # Find the method
            pattern = r'(async def _execute_task_with_agent\(self, task: UnifiedSwarmTask, agent_id: str\)[^:]*:)'
            match = re.search(pattern + r'(.*?)(?=\n    async def|\nclass|\Z)', content, re.DOTALL)
            
            if match:
                method_start = match.group(1)
                
                # Create a working implementation
                new_body = '''
        """Execute a task with an agent and create real files"""
        try:
            agent = self.agents.get(agent_id)
            if not agent:
                logger.error(f"Agent {agent_id} not found")
                return None
                
            logger.info(f"üéØ {agent.name} executing task: {task.description}")
            
            # Create workspace directory
            workspace = "agent_workspace"
            os.makedirs(workspace, exist_ok=True)
            
            # Determine what to create based on task
            files_created = []
            
            if "test" in task.description.lower():
                # Create test file
                content = """import unittest

class TestExample(unittest.TestCase):
    def test_basic(self):
        self.assertEqual(1 + 1, 2)
    
    def test_string(self):
        self.assertEqual("hello".upper(), "HELLO")
        
if __name__ == '__main__':
    unittest.main()
"""
                filepath = os.path.join(workspace, f"test_{task.id[:8]}.py")
                with open(filepath, 'w') as f:
                    f.write(content)
                files_created.append(filepath)
                
            elif "library" in task.description.lower() or "lib" in task.description.lower():
                # Create library structure
                lib_name = f"lib_{task.id[:8]}"
                lib_path = os.path.join(workspace, lib_name)
                os.makedirs(lib_path, exist_ok=True)
                
                # Create __init__.py
                init_content = f"""\"\"\"
{lib_name} - Generated by {agent.name}
\"\"\"

__version__ = "0.1.0"

from .core import ExampleClass
__all__ = ["ExampleClass"]
"""
                with open(os.path.join(lib_path, "__init__.py"), 'w') as f:
                    f.write(init_content)
                files_created.append(os.path.join(lib_path, "__init__.py"))
                
                # Create core.py
                core_content = """class ExampleClass:
    def __init__(self, name="Example"):
        self.name = name
        
    def greet(self):
        return f"Hello from {self.name}!"
"""
                with open(os.path.join(lib_path, "core.py"), 'w') as f:
                    f.write(core_content)
                files_created.append(os.path.join(lib_path, "core.py"))
                
            elif "api" in task.description.lower() or "rest" in task.description.lower():
                # Create API file
                api_content = """from flask import Flask, jsonify, request
from datetime import datetime

app = Flask(__name__)
data_store = []

@app.route('/health', methods=['GET'])
def health():
    return jsonify({"status": "healthy", "timestamp": str(datetime.utcnow())})

@app.route('/items', methods=['GET'])
def get_items():
    return jsonify({"items": data_store, "count": len(data_store)})

@app.route('/items', methods=['POST'])
def add_item():
    item = request.json
    data_store.append(item)
    return jsonify({"message": "Item added", "item": item}), 201

if __name__ == '__main__':
    app.run(debug=True, port=5000)
"""
                filepath = os.path.join(workspace, f"api_{task.id[:8]}.py")
                with open(filepath, 'w') as f:
                    f.write(api_content)
                files_created.append(filepath)
                
            else:
                # Generic Python file
                content = f'''\"\"\"
Generated by {agent.name}
Task: {task.description}
\"\"\"

def main():
    print("Task completed: {task.description}")
    print("Agent: {agent.name}")
    
if __name__ == "__main__":
    main()
'''
                filepath = os.path.join(workspace, f"output_{task.id[:8]}.py")
                with open(filepath, 'w') as f:
                    f.write(content)
                files_created.append(filepath)
            
            # Log created files
            for fp in files_created:
                logger.info(f"‚úÖ Created file: {fp}")
            
            # Update task status
            task.state = TaskState.COMPLETED
            task.assigned_agent = agent_id
            task.result = {
                "status": "completed",
                "files_created": files_created,
                "agent": agent.name,
                "timestamp": datetime.utcnow().isoformat()
            }
            
            # Update metrics
            self.metrics.tasks_completed += 1
            self.agent_load[agent_id] = max(0, self.agent_load.get(agent_id, 0) - 1)
            
            return task.result
            
        except Exception as e:
            logger.error(f"Task execution error: {e}")
            task.state = TaskState.FAILED
            task.error = str(e)
            self.metrics.tasks_failed += 1
            return None'''
                
                # Replace the method
                new_method = method_start + new_body
                content = re.sub(pattern + r'.*?(?=\n    async def|\nclass|\Z)', 
                               new_method + '\n', content, flags=re.DOTALL)
                
                # Save the fixed file
                with open(file_path, 'w') as f:
                    f.write(content)
                
                print("‚úÖ Fixed task execution to create real files")
                return True
            else:
                print("‚ö†Ô∏è Could not find _execute_task_with_agent method")
                return False
        else:
            print("‚úÖ Task execution already creates files")
            return True
            
    except Exception as e:
        print(f"‚ùå Error ensuring task execution: {e}")
        return False

def create_test_script():
    """Create a test script to verify the fixes work"""
    print("\nüîß Creating test script...")
    
    test_script = '''#!/usr/bin/env python3
"""Test script to verify all fixes work correctly"""

import asyncio
import sys
import os
sys.path.insert(0, '/app/src')

async def test_fixed_swarm():
    """Test the fixed swarm_mas_unified.py"""
    print("\\nüß™ Testing Fixed Swarm\\n")
    
    from swarm_mas_unified import UnifiedSwarmCoordinator
    
    # Initialize
    coordinator = UnifiedSwarmCoordinator(max_agents=5)
    await coordinator.initialize()
    
    # Test request
    result = await coordinator.submit_request("create a test file and a python library")
    
    # Check results
    print(f"Status: {result.get('status')}")
    print(f"Tasks completed: {result.get('task_count', 0)}")
    print(f"Success rate: {result.get('success_rate', 0):.1f}%")
    
    # Check created files
    workspace = "agent_workspace"
    if os.path.exists(workspace):
        files = []
        for root, dirs, filenames in os.walk(workspace):
            for filename in filenames:
                files.append(os.path.join(root, filename))
        print(f"\\nFiles created: {len(files)}")
        for f in files[:5]:  # Show first 5 files
            print(f"  - {f}")
        if len(files) > 5:
            print(f"  ... and {len(files) - 5} more files")
    
    return result.get('success_rate', 0) > 0

if __name__ == "__main__":
    success = asyncio.run(test_fixed_swarm())
    if success:
        print("\\n‚úÖ All tests passed!")
    else:
        print("\\n‚ùå Tests failed!")
    '''
    
    test_path = '/app/src/test_fixes.py'
    with open(test_path, 'w') as f:
        f.write(test_script)
    os.chmod(test_path, 0o755)
    
    print(f"‚úÖ Created test script: {test_path}")
    return test_path

def main():
    """Apply all fixes"""
    print("="*60)
    print("üöÄ APPLYING ALL FIXES TO MAS SYSTEM")
    print("="*60)
    
    # Track results
    results = {
        'visibility_fix': False,
        'task_execution_fix': False,
        'test_script': False
    }
    
    # Apply fixes
    results['visibility_fix'] = fix_visibility_level_comparison()
    results['task_execution_fix'] = ensure_task_execution()
    
    # Create test script
    test_path = create_test_script()
    results['test_script'] = bool(test_path)
    
    # Summary
    print("\n" + "="*60)
    print("üìä SUMMARY")
    print("="*60)
    
    for fix, success in results.items():
        status = "‚úÖ" if success else "‚ùå"
        print(f"{status} {fix.replace('_', ' ').title()}")
    
    if all(results.values()):
        print("\n‚úÖ All fixes applied successfully!")
        print(f"\nüß™ Run the test script to verify:")
        print(f"   docker exec mas-production-system-core-1 python {test_path}")
    else:
        print("\n‚ö†Ô∏è Some fixes failed. Please check the logs.")
    
    print("\nüìù To use the fixed swarm:")
    print('   docker exec mas-production-system-core-1 python /app/src/swarm_mas_unified.py \\')
    print('     --mode request --request "your request here"')

if __name__ == "__main__":
    main()